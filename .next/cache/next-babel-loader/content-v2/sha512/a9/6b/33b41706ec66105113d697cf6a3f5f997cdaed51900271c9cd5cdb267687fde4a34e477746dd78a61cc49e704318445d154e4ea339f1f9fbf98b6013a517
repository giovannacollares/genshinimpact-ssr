{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getSortedRoutes = getSortedRoutes;\n\nclass UrlNode {\n  constructor() {\n    this.placeholder = true;\n    this.children = new Map();\n    this.slugName = null;\n    this.restSlugName = null;\n    this.optionalRestSlugName = null;\n  }\n\n  insert(urlPath) {\n    this._insert(urlPath.split('/').filter(Boolean), [], false);\n  }\n\n  smoosh() {\n    return this._smoosh();\n  }\n\n  _smoosh(prefix = '/') {\n    const childrenPaths = [...this.children.keys()].sort();\n\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n    }\n\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);\n    }\n\n    const routes = childrenPaths.map(c => this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr) => [...prev, ...curr], []);\n\n    if (this.slugName !== null) {\n      routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n    }\n\n    if (!this.placeholder) {\n      const r = prefix === '/' ? '/' : prefix.slice(0, -1);\n\n      if (this.optionalRestSlugName != null) {\n        throw new Error(`You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`);\n      }\n\n      routes.unshift(r);\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      routes.push(...this.children.get('[[...]]')._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));\n    }\n\n    return routes;\n  }\n\n  _insert(urlPaths, slugNames, isCatchAll) {\n    if (urlPaths.length === 0) {\n      this.placeholder = false;\n      return;\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`);\n    } // The next segment in the urlPaths list\n\n\n    let nextSegment = urlPaths[0]; // Check if the segment matches `[something]`\n\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1);\n      let isOptional = false;\n\n      if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n        // Strip optional `[` and `]`, leaving only `something`\n        segmentName = segmentName.slice(1, -1);\n        isOptional = true;\n      }\n\n      if (segmentName.startsWith('...')) {\n        // Strip `...`, leaving only `something`\n        segmentName = segmentName.substring(3);\n        isCatchAll = true;\n      }\n\n      if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n        throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n      }\n\n      function handleSlug(previousSlug, nextSlug) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an err.sh link, the description can be based on above comment.\n            throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n          }\n        }\n\n        slugNames.forEach(slug => {\n          if (slug === nextSlug) {\n            throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n          }\n\n          if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n            throw new Error(`You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`);\n          }\n        });\n        slugNames.push(nextSlug);\n      }\n\n      if (isCatchAll) {\n        if (isOptional) {\n          if (this.restSlugName != null) {\n            throw new Error(`You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`);\n          }\n\n          handleSlug(this.optionalRestSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n          this.optionalRestSlugName = segmentName; // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n\n          nextSegment = '[[...]]';\n        } else {\n          if (this.optionalRestSlugName != null) {\n            throw new Error(`You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`);\n          }\n\n          handleSlug(this.restSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n          this.restSlugName = segmentName; // nextSegment is overwritten to [...] so that it can later be sorted specifically\n\n          nextSegment = '[...]';\n        }\n      } else {\n        if (isOptional) {\n          throw new Error(`Optional route parameters are not yet supported (\"${urlPaths[0]}\").`);\n        }\n\n        handleSlug(this.slugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n        this.slugName = segmentName; // nextSegment is overwritten to [] so that it can later be sorted specifically\n\n        nextSegment = '[]';\n      }\n    } // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n\n\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode());\n    }\n\n    this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n  }\n\n}\n\nfunction getSortedRoutes(normalizedPages) {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode(); // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n\n  normalizedPages.forEach(pagePath => root.insert(pagePath)); // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n\n  return root.smoosh();\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/sorted-routes.ts"],"names":["UrlNode","insert","urlPath","smoosh","_smoosh","prefix","childrenPaths","routes","c","slugName","r","optionalRestSlugName","restSlugName","_insert","urlPaths","nextSegment","segmentName","isOptional","isCatchAll","previousSlug","nextSlug","slugNames","slug","handleSlug","root","normalizedPages","pagePath"],"mappings":"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","sourcesContent":["class UrlNode {\n  placeholder: boolean = true\n  children: Map<string, UrlNode> = new Map()\n  slugName: string | null = null\n  restSlugName: string | null = null\n  optionalRestSlugName: string | null = null\n\n  insert(urlPath: string): void {\n    this._insert(urlPath.split('/').filter(Boolean), [], false)\n  }\n\n  smoosh(): string[] {\n    return this._smoosh()\n  }\n\n  private _smoosh(prefix: string = '/'): string[] {\n    const childrenPaths = [...this.children.keys()].sort()\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1)\n    }\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1)\n    }\n    if (this.optionalRestSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1)\n    }\n\n    const routes = childrenPaths\n      .map((c) => this.children.get(c)!._smoosh(`${prefix}${c}/`))\n      .reduce((prev, curr) => [...prev, ...curr], [])\n\n    if (this.slugName !== null) {\n      routes.push(\n        ...this.children.get('[]')!._smoosh(`${prefix}[${this.slugName}]/`)\n      )\n    }\n\n    if (!this.placeholder) {\n      const r = prefix === '/' ? '/' : prefix.slice(0, -1)\n      if (this.optionalRestSlugName != null) {\n        throw new Error(\n          `You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`\n        )\n      }\n\n      routes.unshift(r)\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(\n        ...this.children\n          .get('[...]')!\n          ._smoosh(`${prefix}[...${this.restSlugName}]/`)\n      )\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      routes.push(\n        ...this.children\n          .get('[[...]]')!\n          ._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`)\n      )\n    }\n\n    return routes\n  }\n\n  private _insert(\n    urlPaths: string[],\n    slugNames: string[],\n    isCatchAll: boolean\n  ): void {\n    if (urlPaths.length === 0) {\n      this.placeholder = false\n      return\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`)\n    }\n\n    // The next segment in the urlPaths list\n    let nextSegment = urlPaths[0]\n\n    // Check if the segment matches `[something]`\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1)\n\n      let isOptional = false\n      if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n        // Strip optional `[` and `]`, leaving only `something`\n        segmentName = segmentName.slice(1, -1)\n        isOptional = true\n      }\n\n      if (segmentName.startsWith('...')) {\n        // Strip `...`, leaving only `something`\n        segmentName = segmentName.substring(3)\n        isCatchAll = true\n      }\n\n      if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n        throw new Error(\n          `Segment names may not start or end with extra brackets ('${segmentName}').`\n        )\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(\n          `Segment names may not start with erroneous periods ('${segmentName}').`\n        )\n      }\n\n      function handleSlug(previousSlug: string | null, nextSlug: string) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an err.sh link, the description can be based on above comment.\n            throw new Error(\n              `You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`\n            )\n          }\n        }\n\n        slugNames.forEach((slug) => {\n          if (slug === nextSlug) {\n            throw new Error(\n              `You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`\n            )\n          }\n\n          if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n            throw new Error(\n              `You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`\n            )\n          }\n        })\n\n        slugNames.push(nextSlug)\n      }\n\n      if (isCatchAll) {\n        if (isOptional) {\n          if (this.restSlugName != null) {\n            throw new Error(\n              `You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`\n            )\n          }\n\n          handleSlug(this.optionalRestSlugName, segmentName)\n          // slugName is kept as it can only be one particular slugName\n          this.optionalRestSlugName = segmentName\n          // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n          nextSegment = '[[...]]'\n        } else {\n          if (this.optionalRestSlugName != null) {\n            throw new Error(\n              `You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`\n            )\n          }\n\n          handleSlug(this.restSlugName, segmentName)\n          // slugName is kept as it can only be one particular slugName\n          this.restSlugName = segmentName\n          // nextSegment is overwritten to [...] so that it can later be sorted specifically\n          nextSegment = '[...]'\n        }\n      } else {\n        if (isOptional) {\n          throw new Error(\n            `Optional route parameters are not yet supported (\"${urlPaths[0]}\").`\n          )\n        }\n        handleSlug(this.slugName, segmentName)\n        // slugName is kept as it can only be one particular slugName\n        this.slugName = segmentName\n        // nextSegment is overwritten to [] so that it can later be sorted specifically\n        nextSegment = '[]'\n      }\n    }\n\n    // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode())\n    }\n\n    this.children\n      .get(nextSegment)!\n      ._insert(urlPaths.slice(1), slugNames, isCatchAll)\n  }\n}\n\nexport function getSortedRoutes(normalizedPages: string[]): string[] {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode()\n\n  // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n  normalizedPages.forEach((pagePath) => root.insert(pagePath))\n  // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n  return root.smoosh()\n}\n"]},"metadata":{},"sourceType":"script"}