{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _nodeHtmlParser = require(\"node-html-parser\");\n\nvar _constants = require(\"./constants\"); // const MIDDLEWARE_TIME_BUDGET = parseInt(process.env.__POST_PROCESS_MIDDLEWARE_TIME_BUDGET || '', 10) || 10\n\n\nconst MAXIMUM_IMAGE_PRELOADS = 2;\nconst IMAGE_PRELOAD_SIZE_THRESHOLD = 2500;\nconst middlewareRegistry = [];\n\nfunction registerPostProcessor(name, middleware, condition) {\n  middlewareRegistry.push({\n    name,\n    middleware,\n    condition: condition || null\n  });\n}\n\nasync function processHTML(html, data, options) {\n  // Don't parse unless there's at least one processor middleware\n  if (!middlewareRegistry[0]) {\n    return html;\n  }\n\n  const postProcessData = {\n    preloads: {\n      images: []\n    }\n  };\n  const root = (0, _nodeHtmlParser.parse)(html);\n  let document = html; // Calls the middleware, with some instrumentation and logging\n\n  async function callMiddleWare(middleware) {\n    // let timer = Date.now()\n    middleware.inspect(root, postProcessData, data);\n    document = await middleware.mutate(document, postProcessData, data); // timer = Date.now() - timer\n    // if (timer > MIDDLEWARE_TIME_BUDGET) {\n    // TODO: Identify a correct upper limit for the postprocess step\n    // and add a warning to disable the optimization\n    // }\n\n    return;\n  }\n\n  for (let i = 0; i < middlewareRegistry.length; i++) {\n    let middleware = middlewareRegistry[i];\n\n    if (!middleware.condition || middleware.condition(options)) {\n      await callMiddleWare(middlewareRegistry[i].middleware);\n    }\n  }\n\n  return document;\n}\n\nclass FontOptimizerMiddleware {\n  constructor() {\n    this.fontDefinitions = [];\n\n    this.mutate = async (markup, _data, options) => {\n      let result = markup;\n\n      if (!options.getFontDefinition) {\n        return markup;\n      }\n\n      for (const key in this.fontDefinitions) {\n        const [url, nonce] = this.fontDefinitions[key];\n        const fallBackLinkTag = `<link rel=\"stylesheet\" href=\"${url}\"/>`;\n\n        if (result.indexOf(`<style data-href=\"${url}\">`) > -1 || result.indexOf(fallBackLinkTag) > -1) {\n          // The font is already optimized and probably the response is cached\n          continue;\n        }\n\n        const fontContent = options.getFontDefinition(url);\n\n        if (!fontContent) {\n          /**\n          * In case of unreachable font definitions, fallback to default link tag.\n          */\n          result = result.replace('</head>', `${fallBackLinkTag}</head>`);\n        } else {\n          const nonceStr = nonce ? ` nonce=\"${nonce}\"` : '';\n          result = result.replace('</head>', `<style data-href=\"${url}\"${nonceStr}>${fontContent}</style></head>`);\n        }\n      }\n\n      return result;\n    };\n  }\n\n  inspect(originalDom, _data, options) {\n    if (!options.getFontDefinition) {\n      return;\n    } // collecting all the requested font definitions\n\n\n    originalDom.querySelectorAll('link').filter(tag => tag.getAttribute('rel') === 'stylesheet' && tag.hasAttribute('data-href') && _constants.OPTIMIZED_FONT_PROVIDERS.some(url => {\n      const dataHref = tag.getAttribute('data-href');\n      return dataHref ? dataHref.startsWith(url) : false;\n    })).forEach(element => {\n      const url = element.getAttribute('data-href');\n      const nonce = element.getAttribute('nonce');\n\n      if (url) {\n        this.fontDefinitions.push([url, nonce]);\n      }\n    });\n  }\n\n}\n\nclass ImageOptimizerMiddleware {\n  constructor() {\n    this.mutate = async (markup, _data) => {\n      let result = markup;\n\n      let imagePreloadTags = _data.preloads.images.filter(imgHref => !preloadTagAlreadyExists(markup, imgHref)).reduce((acc, imgHref) => acc + `<link rel=\"preload\" href=\"${imgHref}\" as=\"image\"/>`, '');\n\n      return result.replace(/<link rel=\"preload\"/, `${imagePreloadTags}<link rel=\"preload\"`);\n    };\n  }\n\n  inspect(originalDom, _data) {\n    const imgElements = originalDom.querySelectorAll('img');\n    let eligibleImages = [];\n\n    for (let i = 0; i < imgElements.length; i++) {\n      if (isImgEligible(imgElements[i])) {\n        eligibleImages.push(imgElements[i]);\n      }\n\n      if (eligibleImages.length >= MAXIMUM_IMAGE_PRELOADS) {\n        break;\n      }\n    }\n\n    _data.preloads.images = [];\n\n    for (const imgEl of eligibleImages) {\n      const src = imgEl.getAttribute('src');\n\n      if (src) {\n        _data.preloads.images.push(src);\n      }\n    }\n  }\n\n}\n\nfunction isImgEligible(imgElement) {\n  let imgSrc = imgElement.getAttribute('src');\n  return !!imgSrc && sourceIsSupportedType(imgSrc) && imageIsNotTooSmall(imgElement) && imageIsNotHidden(imgElement);\n}\n\nfunction preloadTagAlreadyExists(html, href) {\n  const regex = new RegExp(`<link[^>]*href[^>]*${href}`);\n  return html.match(regex);\n}\n\nfunction imageIsNotTooSmall(imgElement) {\n  // Skip images without both height and width--we don't know enough to say if\n  // they are too small\n  if (!(imgElement.hasAttribute('height') && imgElement.hasAttribute('width'))) {\n    return true;\n  }\n\n  try {\n    const heightAttr = imgElement.getAttribute('height');\n    const widthAttr = imgElement.getAttribute('width');\n\n    if (!heightAttr || !widthAttr) {\n      return true;\n    }\n\n    if (parseInt(heightAttr) * parseInt(widthAttr) <= IMAGE_PRELOAD_SIZE_THRESHOLD) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  return true;\n} // Traverse up the dom from each image to see if it or any of it's\n// ancestors have the hidden attribute.\n\n\nfunction imageIsNotHidden(imgElement) {\n  let activeElement = imgElement;\n\n  while (activeElement.parentNode) {\n    if (activeElement.hasAttribute('hidden')) {\n      return false;\n    }\n\n    activeElement = activeElement.parentNode;\n  }\n\n  return true;\n} // Currently only filters out svg images--could be made more specific in the future.\n\n\nfunction sourceIsSupportedType(imgSrc) {\n  return !imgSrc.includes('.svg');\n} // Initialization\n\n\nregisterPostProcessor('Inline-Fonts', new FontOptimizerMiddleware(), // Using process.env because passing Experimental flag through loader is not possible.\n// @ts-ignore\noptions => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS);\nregisterPostProcessor('Preload Images', new ImageOptimizerMiddleware(), // @ts-ignore\noptions => options.optimizeImages || process.env.__NEXT_OPTIMIZE_IMAGES);\nvar _default = processHTML;\nexports.default = _default;","map":{"version":3,"sources":["../../../next-server/lib/post-process.ts"],"names":["MAXIMUM_IMAGE_PRELOADS","IMAGE_PRELOAD_SIZE_THRESHOLD","middlewareRegistry","condition","postProcessData","preloads","images","root","document","middleware","i","callMiddleWare","FontOptimizerMiddleware","inspect","options","originalDom","tag","OPTIMIZED_FONT_PROVIDERS","url","dataHref","element","nonce","result","fallBackLinkTag","fontContent","nonceStr","ImageOptimizerMiddleware","imgElements","eligibleImages","isImgEligible","_data","src","imgEl","imagePreloadTags","imgHref","preloadTagAlreadyExists","acc","imgSrc","imgElement","sourceIsSupportedType","imageIsNotTooSmall","imageIsNotHidden","regex","href","html","heightAttr","widthAttr","parseInt","activeElement","registerPostProcessor","process","processHTML"],"mappings":"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","sourcesContent":["import { parse, HTMLElement } from 'node-html-parser'\nimport { OPTIMIZED_FONT_PROVIDERS } from './constants'\n\n// const MIDDLEWARE_TIME_BUDGET = parseInt(process.env.__POST_PROCESS_MIDDLEWARE_TIME_BUDGET || '', 10) || 10\nconst MAXIMUM_IMAGE_PRELOADS = 2\nconst IMAGE_PRELOAD_SIZE_THRESHOLD = 2500\n\ntype postProcessOptions = {\n  optimizeFonts: boolean\n  optimizeImages: boolean\n}\n\ntype renderOptions = {\n  getFontDefinition?: (url: string) => string\n}\n\ntype postProcessData = {\n  preloads: {\n    images: Array<string>\n  }\n}\n\ninterface PostProcessMiddleware {\n  inspect: (\n    originalDom: HTMLElement,\n    data: postProcessData,\n    options: renderOptions\n  ) => void\n  mutate: (\n    markup: string,\n    data: postProcessData,\n    options: renderOptions\n  ) => Promise<string>\n}\n\ntype middlewareSignature = {\n  name: string\n  middleware: PostProcessMiddleware\n  condition: ((options: postProcessOptions) => boolean) | null\n}\n\nconst middlewareRegistry: Array<middlewareSignature> = []\n\nfunction registerPostProcessor(\n  name: string,\n  middleware: PostProcessMiddleware,\n  condition?: (options: postProcessOptions) => boolean\n) {\n  middlewareRegistry.push({ name, middleware, condition: condition || null })\n}\n\nasync function processHTML(\n  html: string,\n  data: renderOptions,\n  options: postProcessOptions\n): Promise<string> {\n  // Don't parse unless there's at least one processor middleware\n  if (!middlewareRegistry[0]) {\n    return html\n  }\n  const postProcessData: postProcessData = {\n    preloads: {\n      images: [],\n    },\n  }\n  const root: HTMLElement = parse(html)\n  let document = html\n  // Calls the middleware, with some instrumentation and logging\n  async function callMiddleWare(middleware: PostProcessMiddleware) {\n    // let timer = Date.now()\n    middleware.inspect(root, postProcessData, data)\n    document = await middleware.mutate(document, postProcessData, data)\n    // timer = Date.now() - timer\n    // if (timer > MIDDLEWARE_TIME_BUDGET) {\n    // TODO: Identify a correct upper limit for the postprocess step\n    // and add a warning to disable the optimization\n    // }\n    return\n  }\n\n  for (let i = 0; i < middlewareRegistry.length; i++) {\n    let middleware = middlewareRegistry[i]\n    if (!middleware.condition || middleware.condition(options)) {\n      await callMiddleWare(middlewareRegistry[i].middleware)\n    }\n  }\n\n  return document\n}\n\nclass FontOptimizerMiddleware implements PostProcessMiddleware {\n  fontDefinitions: (string | undefined)[][] = []\n  inspect(\n    originalDom: HTMLElement,\n    _data: postProcessData,\n    options: renderOptions\n  ) {\n    if (!options.getFontDefinition) {\n      return\n    }\n    // collecting all the requested font definitions\n    originalDom\n      .querySelectorAll('link')\n      .filter(\n        (tag: HTMLElement) =>\n          tag.getAttribute('rel') === 'stylesheet' &&\n          tag.hasAttribute('data-href') &&\n          OPTIMIZED_FONT_PROVIDERS.some((url) => {\n            const dataHref = tag.getAttribute('data-href')\n            return dataHref ? dataHref.startsWith(url) : false\n          })\n      )\n      .forEach((element: HTMLElement) => {\n        const url = element.getAttribute('data-href')\n        const nonce = element.getAttribute('nonce')\n\n        if (url) {\n          this.fontDefinitions.push([url, nonce])\n        }\n      })\n  }\n  mutate = async (\n    markup: string,\n    _data: postProcessData,\n    options: renderOptions\n  ) => {\n    let result = markup\n    if (!options.getFontDefinition) {\n      return markup\n    }\n    for (const key in this.fontDefinitions) {\n      const [url, nonce] = this.fontDefinitions[key]\n      const fallBackLinkTag = `<link rel=\"stylesheet\" href=\"${url}\"/>`\n      if (\n        result.indexOf(`<style data-href=\"${url}\">`) > -1 ||\n        result.indexOf(fallBackLinkTag) > -1\n      ) {\n        // The font is already optimized and probably the response is cached\n        continue\n      }\n      const fontContent = options.getFontDefinition(url as string)\n      if (!fontContent) {\n        /**\n         * In case of unreachable font definitions, fallback to default link tag.\n         */\n        result = result.replace('</head>', `${fallBackLinkTag}</head>`)\n      } else {\n        const nonceStr = nonce ? ` nonce=\"${nonce}\"` : ''\n        result = result.replace(\n          '</head>',\n          `<style data-href=\"${url}\"${nonceStr}>${fontContent}</style></head>`\n        )\n      }\n    }\n    return result\n  }\n}\n\nclass ImageOptimizerMiddleware implements PostProcessMiddleware {\n  inspect(originalDom: HTMLElement, _data: postProcessData) {\n    const imgElements = originalDom.querySelectorAll('img')\n    let eligibleImages: Array<HTMLElement> = []\n    for (let i = 0; i < imgElements.length; i++) {\n      if (isImgEligible(imgElements[i])) {\n        eligibleImages.push(imgElements[i])\n      }\n      if (eligibleImages.length >= MAXIMUM_IMAGE_PRELOADS) {\n        break\n      }\n    }\n\n    _data.preloads.images = []\n\n    for (const imgEl of eligibleImages) {\n      const src = imgEl.getAttribute('src')\n      if (src) {\n        _data.preloads.images.push(src)\n      }\n    }\n  }\n  mutate = async (markup: string, _data: postProcessData) => {\n    let result = markup\n    let imagePreloadTags = _data.preloads.images\n      .filter((imgHref) => !preloadTagAlreadyExists(markup, imgHref))\n      .reduce(\n        (acc, imgHref) =>\n          acc + `<link rel=\"preload\" href=\"${imgHref}\" as=\"image\"/>`,\n        ''\n      )\n    return result.replace(\n      /<link rel=\"preload\"/,\n      `${imagePreloadTags}<link rel=\"preload\"`\n    )\n  }\n}\n\nfunction isImgEligible(imgElement: HTMLElement): boolean {\n  let imgSrc = imgElement.getAttribute('src')\n  return (\n    !!imgSrc &&\n    sourceIsSupportedType(imgSrc) &&\n    imageIsNotTooSmall(imgElement) &&\n    imageIsNotHidden(imgElement)\n  )\n}\n\nfunction preloadTagAlreadyExists(html: string, href: string) {\n  const regex = new RegExp(`<link[^>]*href[^>]*${href}`)\n  return html.match(regex)\n}\n\nfunction imageIsNotTooSmall(imgElement: HTMLElement): boolean {\n  // Skip images without both height and width--we don't know enough to say if\n  // they are too small\n  if (\n    !(imgElement.hasAttribute('height') && imgElement.hasAttribute('width'))\n  ) {\n    return true\n  }\n  try {\n    const heightAttr = imgElement.getAttribute('height')\n    const widthAttr = imgElement.getAttribute('width')\n    if (!heightAttr || !widthAttr) {\n      return true\n    }\n\n    if (\n      parseInt(heightAttr) * parseInt(widthAttr) <=\n      IMAGE_PRELOAD_SIZE_THRESHOLD\n    ) {\n      return false\n    }\n  } catch (err) {\n    return true\n  }\n  return true\n}\n\n// Traverse up the dom from each image to see if it or any of it's\n// ancestors have the hidden attribute.\nfunction imageIsNotHidden(imgElement: HTMLElement): boolean {\n  let activeElement = imgElement\n  while (activeElement.parentNode) {\n    if (activeElement.hasAttribute('hidden')) {\n      return false\n    }\n    activeElement = activeElement.parentNode as HTMLElement\n  }\n  return true\n}\n\n// Currently only filters out svg images--could be made more specific in the future.\nfunction sourceIsSupportedType(imgSrc: string): boolean {\n  return !imgSrc.includes('.svg')\n}\n\n// Initialization\nregisterPostProcessor(\n  'Inline-Fonts',\n  new FontOptimizerMiddleware(),\n  // Using process.env because passing Experimental flag through loader is not possible.\n  // @ts-ignore\n  (options) => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS\n)\n\nregisterPostProcessor(\n  'Preload Images',\n  new ImageOptimizerMiddleware(),\n  // @ts-ignore\n  (options) => options.optimizeImages || process.env.__NEXT_OPTIMIZE_IMAGES\n)\n\nexport default processHTML\n"]},"metadata":{},"sourceType":"script"}